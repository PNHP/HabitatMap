#-------------------------------------------------------------------------------# Name:        Habitat Re-Map Pre-Processing Tools# Purpose:## Author:      MMoore## Created:     06/28/2021#-------------------------------------------------------------------------------# Import modulesimport arcpy, osfrom arcgis.features import FeatureLayerfrom arcpy.sa import *from datetime import datetimeimport csv# Set tools to overwrite existing outputsarcpy.env.overwriteOutput = Truearcpy.env.workspace = "memory"######################################################################################################################################################## Begin toolbox######################################################################################################################################################class Toolbox(object):    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the .pyt file)."""        self.label = "HabitatMap_ProcessingTools"        self.alias = "Habitat Map Processing Tools"        self.canRunInBackground = False        self.tools = [preprocess,polytoraster,SplitRasters,HabitatRasterEraser]######################################################################################################################################################## ######################################################################################################################################################class preprocess(object):    def __init__(self):        self.label = "Clip, Snap, Resample, and Project"        self.description = ""        self.canRunInBackground = False    def getParameterInfo(self):        rasters = arcpy.Parameter(            displayName = "Raster files to clip, snap, and project",            name = "rasters",            datatype = "GPRasterLayer",            parameterType = "Required",            direction = "Input",            multiValue = True)        snap_raster = arcpy.Parameter(            displayName = "Snap Raster (must be in desired coordinate system of output)",            name = "snap_raster",            datatype = "GPRasterLayer",            parameterType = "Required",            direction = "Input")        clip_layer = arcpy.Parameter(            displayName = "Clip Layer (must be in desired coordinate system of output)",            name = "clip_layer",            datatype = "GPFeatureLayer",            parameterType = "Required",            direction = "Input")        cell_size = arcpy.Parameter(            displayName = "Output Cell Size",            name = "cell_size",            datatype = "GPString",            parameterType = "Required",            direction = "Input")        outputGDB = arcpy.Parameter(            displayName = "GDB for output processed layers",            name = "outputGDB",            datatype = "DEWorkspace",            parameterType = "Required",            direction = "Input")        params = [rasters,snap_raster,clip_layer,cell_size,outputGDB]        return params    def isLicensed(self):        return True    def updateParameters(self, params):        return    def updateMessages(self, params):        return    def execute(self, params, messages):        rasters = params[0].valueAsText        rasters = rasters.split(";")        snap_raster = params[1].valueAsText        clip_layer = params[2].valueAsText        cell_size = params[3].valueAsText        output_GDB = params[4].valueAsText        arcpy.Delete_management("memory")        scratch_gdb = r"E:\\Projects\\HabitatMap\\Agriculture.gdb"        # Set Snap Raster environment        arcpy.env.snapRaster = snap_raster        arcpy.env.outputCoordinateSystem = arcpy.Describe(snap_raster).spatialReference        for raster in rasters:            now = datetime.now()            current_time = now.strftime("%H:%M:%S")            arcpy.AddMessage("Resampling "+os.path.basename(raster)+": "+current_time)            resample = arcpy.management.Resample(raster,os.path.join(scratch_gdb,"resample"),cell_size,"MAJORITY")            current_time = now.strftime("%H:%M:%S")            arcpy.AddMessage("Clipping "+os.path.basename(raster)+": "+current_time)            clip = arcpy.management.Clip(resample,"",os.path.join(output_GDB,os.path.basename(raster)+"_processed"),in_template_dataset=clip_layer,clipping_geometry="ClippingGeometry")            #arcpy.Delete_management(os.path.join(output_GDB,"resample.tif"))######################################################################################################################################################## ######################################################################################################################################################class polytoraster(object):    def __init__(self):        self.label = "Habitat Polygon to Raster"        self.description = ""        self.canRunInBackground = False    def getParameterInfo(self):        feature = arcpy.Parameter(            displayName = "Input feature layer to become raster",            name = "feature",            datatype = "GPLayer",            parameterType = "Required",            direction = "Input",            multiValue = False)        value_field = arcpy.Parameter(            displayName = "Field used to create raster values",            name = "value_field",            datatype = "Field",            parameterType = "Required",            direction = "Input")        value_field.parameterDependencies = [feature.name]        snap_raster = arcpy.Parameter(            displayName = "Snap Raster (must be in desired coordinate system of output)",            name = "snap_raster",            datatype = "GPRasterLayer",            parameterType = "Required",            direction = "Input")        clip_layer = arcpy.Parameter(            displayName = "Clip Layer (must be in desired coordinate system of output)",            name = "clip_layer",            datatype = "GPFeatureLayer",            parameterType = "Required",            direction = "Input")        resample = arcpy.Parameter(            displayName = "Output Cell Size",            name = "resample",            datatype = "GPString",            parameterType = "Required",            direction = "Input")        codes = arcpy.Parameter(            displayName = "CSV with code key (only use for coded values - otherwise, leave blank)",            name = "codes",            datatype = "DEFile",            parameterType = "Optional",            direction = "Input")        output = arcpy.Parameter(            displayName = "Output raster file",            name = "output",            datatype = "GPRasterLayer",            parameterType = "Required",            direction = "Output")        params = [feature,value_field,snap_raster,clip_layer,resample,codes,output]        return params    def isLicensed(self):        return True    def updateParameters(self, params):        return    def updateMessages(self, params):        return    def execute(self, params, messages):        feature = params[0].valueAsText        value_field = params[1].valueAsText        snap_raster = params[2].valueAsText        clip_layer = params[3].valueAsText        resample = params[4].valueAsText        codes = params[5].valueAsText        output = params[6].valueAsText        arcpy.Delete_management("memory")        # Set Snap Raster environment        arcpy.env.snapRaster = snap_raster        arcpy.env.outputCoordinateSystem = arcpy.Describe(snap_raster).spatialReference        poly_to_raster = arcpy.PolygonToRaster_conversion(feature,value_field,os.path.join(os.path.dirname(output),"poly_to_raster"),"CELL_CENTER","",resample)        clip = arcpy.management.Clip(poly_to_raster,"",output,in_template_dataset=clip_layer,clipping_geometry="ClippingGeometry")        if codes:            arcpy.AddField_management(clip,"comm_type","TEXT","","",250,"Community Type")            ##arcpy.AlterField_management(clip,value_field,"code","Code")            with open(codes, mode='r') as code:                reader = csv.reader(code)                code_dict = {row[0]:row[1] for row in reader}            with arcpy.da.UpdateCursor(clip,[value_field,"comm_type"]) as cursor:                for row in cursor:                    for k,v in code_dict.items():                        if k == row[0]:                            row[1] = v                            cursor.updateRow(row)        arcpy.Delete_management(os.path.join(os.path.dirname(output),"poly_to_raster"))##############################################################################################################################################################################################################################################################################################################class SplitRasters(object):    def __init__(self):        self.label = "Split raster by values"        self.description = ""        self.canRunInBackground = False    def getParameterInfo(self):        raster = arcpy.Parameter(            displayName = "Raster file to split by values",            name = "raster",            datatype = "GPRasterLayer",            parameterType = "Required",            direction = "Input",            multiValue = False)        comm_name_field = arcpy.Parameter(            displayName = "Community name field",            name = "comm_name_field",            datatype = "Field",            parameterType = "Required",            direction = "Input")        comm_name_field.parameterDependencies = [raster.name]        outputName = arcpy.Parameter(            displayName = "Output name for rasters",            name = "outputName",            datatype = "GPString",            parameterType = "Required",            direction = "Input")        outputGDB = arcpy.Parameter(            displayName = "GDB for output processed layers",            name = "outputGDB",            datatype = "DEWorkspace",            parameterType = "Required",            direction = "Input")        snap_raster = arcpy.Parameter(            displayName = "Snap Raster (must be in desired coordinate system of output)",            name = "snap_raster",            datatype = "GPRasterLayer",            parameterType = "Required",            direction = "Input")        params = [raster,comm_name_field,outputName,outputGDB,snap_raster]        return params    def isLicensed(self):        return True    def updateParameters(self, params):        return    def updateMessages(self, params):        return    def execute(self, params, messages):        raster = params[0].valueAsText        comm_name_field = params[1].valueAsText        outputName = params[2].valueAsText        output_GDB = params[3].valueAsText        snap_raster = params[4].valueAsText        arcpy.Delete_management("memory")        # Set Snap Raster environment        arcpy.env.snapRaster = snap_raster        arcpy.env.outputCoordinateSystem = arcpy.Describe(snap_raster).spatialReference        value_list = sorted({row[0] for row in arcpy.da.SearchCursor(raster, ["Value"])})        for v in value_list:            arcpy.AddMessage("Extracting value: "+str(v))            attExtract = ExtractByAttributes(raster,"Value={0}".format(v))            extract = os.path.join(output_GDB,outputName+'_VALUE_'+str(v))            attExtract.save(os.path.join(extract))            arcpy.JoinField_management(extract,"Value",raster,"Value",comm_name_field)            arcpy.RasterToPolygon_conversion(extract,os.path.join(output_GDB,outputName+'_VALUE_'+str(v)+'_poly'))##############################################################################################################################################################################################################################################################################################################class HabitatRasterEraser(object):    def __init__(self):        self.label = "Habitat Raster Eraser"        self.description = ""        self.canRunInBackground = False    def getParameterInfo(self):        input_raster = arcpy.Parameter(            displayName = "Input habitat raster",            name = "input_raster",            datatype = "GPRasterLayer",            parameterType = "Required",            direction = "Input",            multiValue = False)        erase_raster = arcpy.Parameter(            displayName = "Raster used as mask for erased area",            name = "erase_raster",            datatype = "GPRasterLayer",            parameterType = "Required",            direction = "Input",            multiValue = False)        output_raster = arcpy.Parameter(            displayName = "Output habitat raster",            name = "output_raster",            datatype = "GPRasterLayer",            parameterType = "Required",            direction = "Output",            multiValue = False)        snap_raster = arcpy.Parameter(            displayName = "Snap Raster (must be in desired coordinate system of output)",            name = "snap_raster",            datatype = "GPRasterLayer",            parameterType = "Required",            direction = "Input")        params = [input_raster,erase_raster,output_raster,snap_raster]        return params    def isLicensed(self):        return True    def updateParameters(self, params):        return    def updateMessages(self, params):        return    def execute(self, params, messages):        input_raster = params[0].valueAsText        erase_raster = params[1].valueAsText        output_raster = params[2].valueAsText        snap_raster = params[3].valueAsText        # Set Snap Raster environment        arcpy.env.snapRaster = snap_raster        arcpy.env.outputCoordinateSystem = arcpy.Describe(snap_raster).spatialReference        # final_raster = arcpy.management.CopyRaster(input_raster,output_raster)        arcpy.AddMessage("Calculating null cells...")        final_raster = arcpy.sa.SetNull(~(arcpy.sa.IsNull(erase_raster)),input_raster)        arcpy.AddMessage("Saving final raster...")        final_raster.save(output_raster)